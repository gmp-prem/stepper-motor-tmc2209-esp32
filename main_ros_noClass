#include <Arduino.h>
#include "ArduinoHardware.h" // for nh object to recognize method setBaud()
#include <ros.h>

#include <std_msgs/Float64.h>

#include <HardwareSerial.h>

#include <TMCStepper.h>
#include "SpeedyStepper.h"

#define DIAG_PIN         18           // STALL motor 2
#define EN_PIN           5            // Enable
#define DIR_PIN          23           // Direction
#define STEP_PIN         22           // Step
#define SERIAL_PORT      Serial2      // TMC2208/TMC2224 HardwareSerial port
#define DRIVER_ADDRESS   0b00         // TMC2209 Driver address according to MS1 and MS2
#define R_SENSE          0.11f        // R_SENSE for current calc.  
/*
  Higher STALL_VALUE value -> higher torque to indicate the stall and vice versa
  Lower  STALL_VALUE value -> lower torque to indicate stall detection
  the diag_pin will be 1 when SG_THRS*2 > SG_RESULT 
*/
#define STALL_VALUE      2       // [0..255]

hw_timer_t * timer1 = NULL;
TMC2209Stepper driver(&SERIAL_PORT, R_SENSE , DRIVER_ADDRESS);
using namespace TMC2208_n;

SpeedyStepper stepper;

const int ledPin = 2;
bool shaft = false; // for control through the driver
double value = 0;
// ============ START ROS
ros::NodeHandle nh;

// Publishers
std_msgs::Float64 gripper_position_goal_msg;
std_msgs::Float64 gripper_position_current_msg;
ros::Publisher gripper_position_goal("gripper/position_goal", &gripper_position_goal_msg);
ros::Publisher gripper_position_current("gripper/position_current", &gripper_position_current_msg);


// TODO: control (speed, position) in step and mm sep function
void gripperSpeedCB (const std_msgs::Float64& msg) {
  //nh.loginfo("Speed recieved");
  stepper.setSpeedInStepsPerSecond(msg.data);
}

void gripperPositionStepCB (const std_msgs::Float64& msg) {
  //nh.loginfo("Position recieved");
  stepper.moveToPositionInSteps(msg.data);
  gripper_position_goal_msg.data = msg.data;
  
}

void gripperPositionCmCB (const std_msgs::Float64& msg) {
  //nh.loginfo("Position recieved");
  double value = (msg.data); // times 10 for CM unit
  stepper.setupMoveInMillimeters( value ); 

  gripper_position_current_msg.data = stepper.getCurrentPositionInMillimeters();
  gripper_position_goal_msg.data = value - gripper_position_current_msg.data;
  

  gripper_position_goal.publish(&gripper_position_goal_msg);
  //gripper_position_current.publish(&gripper_position_current_msg);
  
  
}

// Subscribers
ros::Subscriber<std_msgs::Float64> gripper_speed_sub("gripper/speed", &gripperSpeedCB);
ros::Subscriber<std_msgs::Float64> gripper_position_step_sub("gripper/position_in_step", &gripperPositionStepCB);
ros::Subscriber<std_msgs::Float64> gripper_position_mm_sub("gripper/position_in_cm", &gripperPositionCmCB);


// ============ END ROS

void homing() {
  nh.loginfo("Homing initialized...");
  driver.SGTHRS(20);
  // set up the speed and accel
  stepper.setSpeedInStepsPerSecond(800);
  stepper.setAccelerationInStepsPerSecondPerSecond(400);
  stepper.setCurrentPositionInSteps(0);
  stepper.setupMoveInSteps(-5000);
  // command servo to move until diag_bool is 1
  while (!stepper.processMovement()) {
    if (digitalRead(DIAG_PIN) == 1) {
      stepper.setupStop();
      nh.loginfo("Stall Detected !");
      break;
    }
  }

  // stepper.setupMoveInSteps(0);
  stepper.setCurrentPositionInSteps(0);
  stepper.setupMoveInSteps(5);
  while (!stepper.motionComplete()) {
    stepper.processMovement();
  }
  // set current step to 0
  stepper.setCurrentPositionInSteps(0);
  stepper.setCurrentPositionInMillimeters(0);
  stepper.setupMoveInMillimeters(0);
  stepper.setupMoveInSteps(0);
}

void setup() {
  Serial.begin(115200);          // Init serial port and set baudrate
  while(!Serial);               // Wait for serial port to connect

  nh.getHardware()->setBaud(115200);
  nh.initNode();

  nh.advertise(gripper_position_goal);
  nh.subscribe(gripper_speed_sub);
  nh.subscribe(gripper_position_step_sub);
  nh.subscribe(gripper_position_mm_sub);

  SERIAL_PORT.begin(115200, SERIAL_8N1, 16, 17); // HW serial btw esp32-tmc2099; baud, config, rx, tx
  
  pinMode(DIAG_PIN ,INPUT);
  pinMode(EN_PIN ,OUTPUT);
  pinMode(STEP_PIN ,OUTPUT);
  pinMode(DIR_PIN ,OUTPUT);

  pinMode(ledPin, OUTPUT);

  digitalWrite(EN_PIN ,HIGH); // true: no output, false: output
  delay(500);
  digitalWrite(EN_PIN ,LOW);
  //digitalWrite(DIR_PIN , shaft);

  driver.begin();
  driver.toff(4);
  driver.blank_time(24);
  driver.rms_current(800); // mA max 1.5
  driver.I_scale_analog(true); // true: Use voltage supplied to VREF as current reference
  driver.microsteps(2); // up to 256 or 1/256
  driver.TCOOLTHRS(0xFFFFF); // 20bit max
  driver.semin(5);
  driver.semax(2);
  driver.sedn(0b01);
  
  //driver.shaft(false); // true=CW/open, false=CCW/close
  driver.pdn_disable(true); // true: PDN_UART input function disabled. Set this bit, when using the UART interface
  driver.pwm_autoscale(true);   // Needed for stealthChop

  stepper.connectToPins(STEP_PIN, DIR_PIN);

  
  // check connection of esp32-tmc2209
  nh.loginfo("Testing tmc2209-esp32 connection...");
  uint8_t connection_result = driver.test_connection();
  if (connection_result) {
      nh.loginfo("connection failed");

      switch(connection_result) {
          case 1: nh.loginfo("Likely cause: loose connection"); break;
          case 2: nh.loginfo("Likely cause: no power"); break;
      }
 
      nh.loginfo("Fix the problem and reset board.");
      
      //delay(5); // for Serial.print
      abort();
  }
  nh.loginfo("tmc2209-esp32 connection is OK");

  driver.SGTHRS(20); // for homing
  homing();
  nh.loginfo("Homing Finished");

  driver.SGTHRS(STALL_VALUE); // normal operation
  driver.microsteps(0);
  nh.loginfo("Stepper Ready");
}

uint32_t previous_time = 0;


void loop() {
  uint32_t current_time = millis();

  stepper.setAccelerationInStepsPerSecondPerSecond(300);
  //stepper.setSpeedInMillimetersPerSecond(100);

  if((current_time - previous_time) > 10) {
    previous_time = current_time;
    
    nh.spinOnce(); // update callback 
  }
  
  while (!stepper.motionComplete()) {
    stepper.processMovement();
    if (digitalRead(DIAG_PIN) == 1) {
      stepper.setupStop();
      break;
    }
  }
 
}

