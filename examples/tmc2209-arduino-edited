#include <TMCStepper.h>
#include <Arduino.h>

#define MAX_SPEED 40
#define MIN_SPEED 1000

#define STALL_VALUE  100

#define EN_PIN 4
#define DIR_PIN 2
#define STEP_PIN 3

// on Nano, any pin can be SW serial
// at higher baudrate, does not work reliable
// guess that is 115200 from community
#define SW_RX 5
#define SW_TX 6
#define SW_BAUDRATE 115200

// #define HW_SERIAL_PORT Serial

#define RATE 100

#define DRIVER_ADDRESS 0b00
#define R_SENSE 0.11f // SilentStepStick series use 0.11
// TMC2209Stepper driver(&SERIAL_PORT, R_SENSE, DRIVER_ADDRESS); // HW Serial Com
TMC2209Stepper driver(SW_RX, SW_TX, R_SENSE, DRIVER_ADDRESS); // SW Serial Com

using namespace TMC2208_n;

#define STEP_PORT       PORTF 
#define STEP_BIT_POS    0

// interrupt service routine
ISR(TIMER1_COMPA_vect) {
    digitalWrite(STEP_PIN, !digitalRead(STEP_PIN));
}

void setup () {
    Serial.begin(115200); // serial port pc-arduino
    // set Serial to !(false)->true to wait port to be connected
    // once connected, Serial will become !(true)->false then while loop break
    while(!Serial);
    Serial.println("Serial port connceted...");

    // begin serial com
    // SERIAL_PORT.begin(SW_BAUDRATE); // HW serial
    driver.beginSerial(SW_BAUDRATE); // SW serial, becareful for not reliable

    // pin mde for SW
    pinMode(SW_RX, INPUT);
    pinMode(SW_TX, OUTPUT);

    // pin mode for tmc2209
    pinMode(EN_PIN, OUTPUT);
    pinMode(STEP_PIN, OUTPUT);
    pinMode(DIR_PIN, OUTPUT);

    digitalWrite(DIR_PIN, HIGH); // TODO report which dir ref to some motoman joint?
    digitalWrite(EN_PIN, LOW); // low=enable hw, high=disable hw

    // driver parameter
    driver.begin();
    driver.toff(5); // Enables driver in software
    driver.blank_time(24);
    driver.rms_current(1500); // motor rms 1500 mA = 1.5A
    driver.microsteps(1);
    driver.TCOOLTHRS(0xFFFFF); // 20bit max, now set to 10bit:1024values (0-1023)
    driver.semin(5);
    driver.semax(2);
    driver.sedn(0b01);
    driver.pdn_disable(true); // set this to 1 when using UART mode

    /* StallGuard4 threshold [0... 255] level for stall detection. It compensates for
       motor specific characteristics and controls sensitivity. A higher value gives a higher
       sensitivity. A higher value makes StallGuard4 more sensitive and requires less torque to
       indicate a stall. The double of this value is compared to SG_RESULT.
       The stall output becomes active if SG_RESULT fall below this value. */
    driver.SGTHRS(STALL_VALUE);

    // check connection of arduino-tmc2209
    
    Serial.println("\nTesting tmc2209-arduino connection...");
    uint8_t connection_result = driver.test_connection();
    if (connection_result) {
        Serial.println("connection failed");
        Serial.print("Likely cause: ");

        switch(connection_result) {
            case 1: Serial.println("loose connection"); break;
            case 2: Serial.println("no power"); break;
        }

        Serial.println("Fix the problem and reset board.");
        
        delay(100); // We need this delay or messages above don't get fully printed out
        abort();
    }

    Serial.println("OK"); // if connection is okay */

    // Set stepper interrupt
    {
        cli();//stop interrupts
        TCCR1A = 0;// set entire TCCR1A register to 0
        TCCR1B = 0;// same for TCCR1B
        TCNT1  = 0;//initialize counter value to 0
        OCR1A = 256;// = (16*10^6) / (1*1024) - 1 (must be <65536)
        // turn on CTC mode
        TCCR1B |= (1 << WGM12);
        // Set CS11 bits for 8 prescaler
        TCCR1B |= (1 << CS11);// | (1 << CS10);
        // enable timer compare interrupt
        TIMSK1 |= (1 << OCIE1A);
        sei();//allow interrupts
    }
}

bool shaft = false;
int max_step = 50;
uint16_t i = max_step;

void loop () {
    static uint32_t last_time = 0;
    uint32_t ms = millis();

    while(Serial.available() > 0) {
        int8_t read_byte = Serial.read();
        #ifdef USING_TMC2660
        if (read_byte == '0')      { TIMSK1 &= ~(1 << OCIE1A); driver.toff(0); }
        else if (read_byte == '1') { TIMSK1 |=  (1 << OCIE1A); driver.toff(driver.savedToff()); }
        #else
        if (read_byte == '0')      { TIMSK1 &= ~(1 << OCIE1A); digitalWrite( EN_PIN, HIGH ); }
        else if (read_byte == '1') { TIMSK1 |=  (1 << OCIE1A); digitalWrite( EN_PIN,  LOW ); }
        #endif
        else if (read_byte == '+') { if (OCR1A > MAX_SPEED) OCR1A -= 20; }
        else if (read_byte == '-') { if (OCR1A < MIN_SPEED) OCR1A += 20; }
    }

    // this loop will work 1 Hz
    if ((ms-last_time) > RATE){
        last_time = ms;

        // do something else here...

        Serial.print("Status: ");
        Serial.print(driver.SG_RESULT());
        Serial.print(" ");
        Serial.print(driver.SG_RESULT() < STALL_VALUE, DEC);
        Serial.print(" ");
        Serial.println(driver.cs2rms(driver.cs_actual()), DEC); 
    }

}
